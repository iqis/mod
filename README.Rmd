---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# mod::ule

<!-- badges: start -->
  [![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/iqis/modular?branch=master&svg=true)](https://ci.appveyor.com/project/iqis/modular)
  [![Travis build status](https://travis-ci.org/iqis/modular.svg?branch=master)](https://travis-ci.org/iqis/modular)
[![Lifecycle: maturing](https://img.shields.io/badge/lifecycle-maturing-blue.svg)](https://www.tidyverse.org/lifecycle/#maturing)
[![CRAN status](https://www.r-pkg.org/badges/version/modular)](https://cran.r-project.org/package=modular)
[![Codecov test coverage](https://codecov.io/gh/iqis/modular/branch/master/graph/badge.svg)](https://codecov.io/gh/iqis/modular?branch=master)
![GitHub License](https://img.shields.io/github/license/iqis/modular)

<!-- badges: end -->

The `mod` package is a lightweight module system; It provides a simple way to structure program and data into modules for programming and interactive use, without the formalities of R packages. 

## Installation

Install the development version from [GitHub](https://github.com/) with:

``` {r eval = FALSE}
devtools::install_github("iqis/modular")
```

## Use
The `mod` package is designed to be used attached or unattached to your working environment. If you use the package unattached, you must always qualify the variable name with `::`, such as `mod::ule()`. However, while inside a module, the `mod` package is always available, so you do not need to use `::`. 

If you wish to attach the package: 
```{r eval = FALSE}
require(mod)
```
Otherwise, just move along! 
This document show examples with the package unattached. 

## Programming Interface

- Make a module:
  - Inline:`mod::module()`/`mod::ule()` 
  - From a file: `mod::acquire()`

- The search path:
  - Attach a module to: `mod::use()`
  - Detach a module from: `mod::drop()`
  
  
- Inside a module:
  - Declare public variables within the module: `provide()`
  - Attach a package locally: `require()`
  - Import variables from another module: `refer()`

## Examples

Define an inline module:
```{r}
my <- mod::ule({
        a <- 1
        b <- 2
        f <- function(x, y) x + y
})
```

The resulting module contains the variables defined within.
```{r}
ls(my)
```

Subset the module.
```{r}
my$a
my$b
my$f(my$a, my$b)
```

Use the `with()` to spare qualification.
```{r}
with(my, 
     f(a,b))
```


### Attach a Module to the Search Path

Just like a package, a module can be attached to the search path.
```{r}
mod::use(my)
```

The `my` module is attached to the search path as "module:my", before other attached packages.
```{r}
search()
```

And you can use the variables inside directly, just like from a package.
```{r}
f(a,b)
```

Detach the module from the search path when done, if desired.
```{r}
drop("my")
```

### Make Variables Available to another Module

Use `refer()` to "import" variables from another module.
```{r}
ls(my)

my_other<- mod::ule({
        refer(my)
        
        c <- 4
        d <- 5
})

ls(my_other)
```



### Private Variables
   
A variable is _private_ if its name starts with `..`.
```{r}
room_101 <- mod::ule({
        ..diary <- "Dear Diary: I used SPSS today..."
        get_diary <- function(){
                ..diary
        }
})
```


A private variable cannot be seen or touched. There is no way to access the `..diary` from the outside, except by a function defined within the module. This can be useful if you want to shield some information from the user or other programs. 
```{r}
ls(room_101)
room_101$..diary
room_101$get_diary()
```

Another way is using `provide()` function to declair public variables, while all others become private.
```{r}
room_102 <- mod::ule({
        provide(open_info, get_classified)
        
        open_info <- "I am a data scientist."
        classified_info <- "I can't get the database driver to work."
        get_classified <- function(){
                classified_info
        }
})

ls(room_102)
room_102$open_info
room_102$classified_info
room_102$get_classified()
```
    


    
### Simlate OOP

The below example simulates one essential behavior of an object in Object-oriented Programming by manipulating the state of `..count`.
```{r}
counter <- mod::ule({
        ..count <- 0
        add_one <- function(){
                #Its necessary to use `<<-` operator, as ..count lives in the parent frame.
                ..count <<- ..count + 1 
        }
        reset <- function(){
                ..count <<- 0
        }
        get_count <- function(){
                ..count
        }
})
```
A variable must be private to be mutable like `..count`. 

The following demonstration should be self-explanatory:
```{r}
counter$get_count() 

counter$add_one() 
counter$add_one() 

counter$get_count() 

counter$reset()

counter$get_count()
```

It is imperative that `mod::ule` be only adopted in the simplest cases. If full-featured OOP is desired, use [`R6`](https://cran.r-project.org/web/packages/R6/index.html).



## Note

#### Environment

A module _is_ an environment. This means that every rule that applies to environments, such as copy-by-reference, applies to modules as well.
```{r}
mode(my)
is.environment(my)
```


### `refer()` and `provide()`, why?
Some may wonder the choice of vocabulary. Further, why not `import()` and `export()`? This is because we feel `import()` and `export()` are used too commonly, in both R, and other popular languages with varying meanings. The `reticulate()` package also uses `import()`. To avoid confusion, we decided to introduce some synonyms. With analogous semantics, [`refer()`](https://clojuredocs.org/clojure.core/refer) is borrowed from Clojure, while [`provide()`](https://docs.racket-lang.org/reference/require.html?q=provide#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._provide%29%29) from Racket; Both languages are R's relatives. 

#### Locked

It is impossible to either change the value of a variable or add a new variable to a module. A private variable's value can only be changed by a function defined within the module, as shown previously.
```{r error = TRUE}
my$a <- 888
my$c <- 666
```

#### Hidden Variables

As a general R rule, names that start with `.` define hidden variables.
```{r}
my_yet_another <- mod::ule({
        .var <- "I'm hidden!"
})
```

Hidden variables are not returned by `ls()`, unless specified.
```{r}
ls(my_yet_another)
ls(my_yet_another, all.names = TRUE)
```

Nonetheless, in `mod::ule`, they are treated the same as public variables.
```{r}
my_yet_another$.var
```

#### Load/Attach from File

```{r}
module_path <- system.file("misc/example_module.R", package = "mod")
```

To load and assign to variable: 
```{r}
example_module <- mod::acquire(module_path)
ls(example_module)
example_module$a
example_module$d()
example_module$e(100)
```

To load and attach to search path:
```{r}
mod::use(module_path)
ls("module:example_module")
a
d()
e(100)
```

